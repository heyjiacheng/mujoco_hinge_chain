================================================================================
                 MUJOCO FORWARD KINEMATICS ANALYSIS - COMPLETE
================================================================================

TASK COMPLETED: Exact understanding of how MuJoCo implements stable forward 
kinematics for hinge joints.

FILES CREATED:
================================================================================

1. MUJOCO_KINEMATICS_STABILITY.md (12 KB)
   └─ Conceptual overview and "why" questions
   └─ Executive summary of stability mechanisms
   └─ Why quaternions, normalization, and off-center correction matter
   └─ Comparison with matrix and Euler angle approaches

2. MUJOCO_KINEMATICS_CODE_REFERENCE.md (18 KB)  
   └─ Complete code snippets for 11 key functions
   └─ Exact line numbers from MuJoCo source
   └─ Inline comments explaining each operation
   └─ Stability tricks highlighted throughout
   └─ Summary table of all mechanisms by line

3. KINEMATICS_ANALYSIS_INDEX.md (10 KB)
   └─ Navigation guide for all documents
   └─ Quick reference card for code locations
   └─ Data flow diagrams (ASCII art)
   └─ Implementation checklist for your code
   └─ Validation questions for testing

ANALYSIS COVERAGE:
================================================================================

mj_kinematics() - Main Forward Kinematics (Lines 37-177)
  ✓ Body initialization (world frame)
  ✓ Free joint handling (direct from qpos)
  ✓ Regular joint processing
  ✓ Parent-to-child transformation
  ✓ Hinge joint specific code (LINES 118-138)
  ✓ Off-center rotation correction (LINES 133-137) ← THE KEY
  ✓ Quaternion normalization (LINES 151)
  ✓ Transform finalization
  ✓ Inertial frames, geometry, sites

mj_comPos() - Composite Inertia & Motion Subspace (Lines 181-259)
  ✓ Subtree center of mass computation
  ✓ Backward accumulation for COM
  ✓ Normalization by subtree mass
  ✓ Inertia transformation (parallel axis theorem)
  ✓ Motion subspace (cdof) in COM frame
  ✓ For HINGE: cdof = [axis, axis × offset]

mj_comVel() - Spatial Velocity (Lines 1932-1997)
  ✓ Forward propagation of body velocities
  ✓ cdof_dot computation (time derivative)
  ✓ Numerical stability tricks
  ✓ For HINGE: cdof_dot = cvel × cdof

Supporting Math Functions:
  ✓ mju_axisAngle2Quat() - Hinge angle to quaternion
  ✓ mju_mulQuat() - Quaternion multiplication
  ✓ mju_rotVecQuat() - Vector rotation by quaternion
  ✓ mju_quat2Mat() - Quaternion to matrix
  ✓ mju_normalize4() - Quaternion normalization
  ✓ mju_inertCom() - Inertia transformation
  ✓ mju_dofCom() - Motion subspace
  ✓ mj_local2Global() - Local to global transform

KEY FINDINGS:
================================================================================

1. THE CRITICAL OFF-CENTER ROTATION CORRECTION (Lines 133-137)
   ────────────────────────────────────────────────────────────
   Without this: body rotates around wrong center, constraints violated
   With this:    joint anchor stays fixed, kinematics stay consistent
   
   Code:
     vec = rotVecQuat(jnt_pos, xquat)
     xpos = xanchor - vec
   
   This is the non-obvious genius of MuJoCo's implementation.

2. QUATERNION NORMALIZATION STRATEGY
   ──────────────────────────────────
   Done at 4 key points:
   - Free joint input (line 63)
   - Mocap body input (line 79)
   - Ball joint (line 125)
   - Body finalization (line 151)
   
   Uses threshold check (mjMINVAL = 1e-8) to avoid unnecessary work.
   Guarantees unit quaternion norm, preventing drift.

3. AXIS-ANGLE TO QUATERNION (Lines 95-112)
   ────────────────────────────────────────
   Zero angle check: if (angle == 0) return identity
   Regular: q = [cos(a/2), sin(a/2)*axis]
   
   Advantage: formula guarantees unit quaternion (sin²+cos²=1)
   No normalization step needed!

4. PARENT-TO-CHILD PROPAGATION
   ───────────────────────────
   Each body depends only on parent's transform
   Error grows linearly through chain, not exponentially
   Forward pass (parents before children) ensures correctness

5. BACKWARD ACCUMULATION FOR COM (Line 190)
   ───────────────────────────────
   Loop goes from high index to low (i = nbody-1 down to 1)
   Ensures children processed before parents
   Critical for correct COM calculation

DATA FLOW:
================================================================================

Step 1: INPUT - qpos array
        └─ Hinge angle for each joint

Step 2: mj_kinematics() - Compute global transforms
        ├─ World frame initialized (identity)
        ├─ For each body:
        │  ├─ Get parent's transform
        │  ├─ Apply fixed offset
        │  ├─ For each joint:
        │  │  ├─ Convert angle to quaternion
        │  │  ├─ Rotate body frame
        │  │  └─ Correct for off-center rotation
        │  ├─ Normalize quaternion
        │  └─ Store: xpos, xquat, xmat
        └─ Transform inertial frames, geoms, sites
        
Step 3: mj_comPos() - Prepare dynamics data
        ├─ Compute subtree COM (backward pass)
        ├─ Transform inertias to COM frame
        └─ Compute motion subspace (cdof)

Step 4: mj_comVel() - Compute velocities
        ├─ Forward pass over bodies
        ├─ For each DOF:
        │  ├─ Compute cdof_dot = cvel × cdof
        │  └─ Update velocity
        └─ Store: cvel, cdof_dot

Step 5: OUTPUT - Updated data structure
        ├─ d->xpos, d->xquat, d->xmat (body positions)
        ├─ d->xipos, d->ximat (inertial frame)
        ├─ d->subtree_com (center of mass)
        ├─ d->cinert (composite inertia)
        ├─ d->cdof, d->cdof_dot (motion subspace)
        ├─ d->cvel (center-of-mass velocity)
        └─ Ready for dynamics calculations

NUMERICAL STABILITY MECHANISMS:
================================================================================

Mechanism                          | Where         | Why
──────────────────────────────────────────────────────────────────────────────
Quaternion representation          | Everywhere    | Avoids gimbal lock
Zero angle optimization            | Line 97-102   | Avoids sin/cos errors
Identity check                     | Line 34-35    | Avoids error accumulation
Periodic normalization             | Lines 63,79.. | Prevents drift
Threshold-based normalization      | Line 256      | Avoids unnecessary work
Off-center rotation correction     | Lines 133-137 | Maintains constraints
Parent-to-child propagation        | Line 50       | Linear error growth
Backward accumulation              | Line 190      | Correct dependency order
Diagonal inertia storage           | Line 403      | Minimizes operations
Fast quaternion formulas           | Throughout    | Minimizes intermediates

EXACT LINE NUMBERS:
================================================================================

FILE: mujoco/src/engine/engine_core_smooth.c

  37-177   mj_kinematics() - Main forward kinematics
   63      Normalize free joint input
   79      Normalize mocap body
  106      Compute joint axis in global frame
  109      Compute joint anchor in global frame
  127      Axis-angle to quaternion for HINGE
  131      Apply quaternion rotation to body frame
  133-137  *** OFF-CENTER ROTATION CORRECTION (THE KEY) ***
  145-146  Store joint anchor and axis
  151      Normalize body quaternion to prevent drift
  154      Convert quaternion to rotation matrix
  
 181-259   mj_comPos() - Composite inertia and motion subspace
  186      Initialize subtree_com with body moment
  191      Backward pass: accumulate to parent
  200      Normalize subtree_com by mass
  208-213  Map inertias to COM frame
  255      Motion subspace for HINGE: cdof = [axis, axis × offset]
  
1932-1997  mj_comVel() - Spatial velocity computation
1985      cdof_dot = cvel × cdof (spatial cross product)

FILE: mujoco/src/engine/engine_util_spatial.c

   27-52   mju_rotVecQuat() - Vector rotation by quaternion
   34-35   Identity check (avoid error accumulation)
   
   65-76   mju_mulQuat() - Quaternion multiplication (Hamilton product)
   
   95-112  mju_axisAngle2Quat() - Angle to quaternion
   97-102  Zero angle check (avoid sin/cos errors)
   
  144-182  mju_quat2Mat() - Quaternion to matrix
  146-156  Identity check (avoid expensive computation)
  
  400-430  mju_inertCom() - Inertia transformation
  403-405  Diagonal inertia storage (minimize operations)
  408-413  Rotation to global frame
  416-421  Parallel axis theorem
  
  445-457  mju_dofCom() - Motion subspace in COM frame

FILE: mujoco/src/engine/engine_util_blas.c

  248-265  mju_normalize4() - Quaternion normalization
  251-255  Zero vector handling
  256      Threshold-based normalization (mjMINVAL = 1e-8)

FILE: mujoco/src/engine/engine_core_util.c

  853-893  mj_local2Global() - Local to global transform

IMPLEMENTATION CHECKLIST FOR YOUR CODE:
================================================================================

When implementing stable hinge kinematics:

☐ Use quaternions, not matrices or Euler angles
  └─ More efficient, avoid gimbal lock
  
☐ Normalize after each quaternion multiply
  └─ Use threshold check (only if |norm-1| > 1e-8)
  
☐ Correct for off-center rotation (THE KEY)
  └─ vec = rotVecQuat(jnt_pos, xquat)
  └─ xpos = xanchor - vec
  
☐ Use axis-angle conversion directly
  └─ q = [cos(angle/2), sin(angle/2)*axis]
  └─ Formula guarantees unit quaternion
  
☐ Check for zero angles
  └─ Avoid sin/cos when angle == 0
  
☐ Check for identity quaternions
  └─ Optimize computation for static bodies
  
☐ Use backward accumulation for COM
  └─ Loop from high index to low
  
☐ Store inertia in diagonal form
  └─ 3 values not 9 (minimize operations)
  
☐ Use fast quaternion formulas
  └─ Minimize intermediate computations
  
☐ Test with long simulations
  └─ Verify no position drift over 1000+ steps

ANSWERS TO YOUR ORIGINAL QUESTIONS:
================================================================================

Q1: How does mj_kinematics() compute body positions from joint positions?
A:  Parent-to-child propagation. Each body:
    1. Gets parent's transform
    2. Applies fixed offset
    3. For each joint: converts qpos to rotation, applies it, corrects position
    4. Normalizes quaternion
    5. Stores result
    
Q2: How does it handle the joint anchor point (xanchor)?
A:  Two phases:
    1. Compute (lines 108-110): xanchor in global frame from parent frame
    2. Correct (lines 133-137): Move body so anchor stays fixed during rotation
    
Q3: How does it correct for off-center rotation?
A:  After rotating body frame (line 131):
    1. Compute where local joint position ends up: vec = rotVecQuat(jnt_pos, xquat)
    2. Move body to keep anchor fixed: xpos = xanchor - vec
    
Q4: What is the exact order of operations?
A:  For each joint:
    1. Compute axis in global frame (line 106)
    2. Compute anchor in global frame (lines 108-110)
    3. Convert angle to quaternion (line 127)
    4. Apply rotation (line 131)
    5. Correct for off-center (lines 133-137)
    6. Store anchor and axis (lines 145-146)
    
Q5: How does mj_comPos() compute cinert, cdof, cdof_dot?
A:  Three substeps:
    1. Compute subtree COM (backward accumulation)
    2. Map inertias to COM frame (parallel axis theorem)
    3. Compute motion subspace in COM frame
    cdof_dot is computed in mj_comVel(): cdof_dot = cvel × cdof

Q6: What values are computed and when?
A:  Position phase (mj_kinematics):
      └─ xpos, xquat, xmat, xanchor, xaxis
    Prepare phase (mj_comPos):
      └─ subtree_com, cinert, cdof
    Velocity phase (mj_comVel):
      └─ cvel, cdof_dot

Q7: Are there numerical stability tricks?
A:  Yes (6 main ones):
    1. Quaternion normalization (periodic)
    2. Zero angle check (avoid sin/cos)
    3. Identity check (avoid computation)
    4. Threshold-based normalization (mjMINVAL)
    5. Off-center correction (constraint maintenance)
    6. Minimal floating-point operations (diagonal inertia)

FINAL SUMMARY:
================================================================================

MuJoCo's forward kinematics is stable because:

1. QUATERNIONS: Avoid gimbal lock, enable smooth interpolation
2. NORMALIZATION: Periodic normalization prevents drift
3. OFF-CENTER CORRECTION: Maintains kinematic constraints
4. EFFICIENT MATH: Fast formulas minimize rounding errors
5. SPECIAL CASES: Zero angle and identity checks avoid unnecessary work
6. PARENT-TO-CHILD: Linear error propagation through chain

The implementation is a masterclass in numerical stability combined with
computational efficiency. The off-center rotation correction (lines 133-137)
is the non-obvious key innovation that keeps the whole system coherent.

================================================================================
