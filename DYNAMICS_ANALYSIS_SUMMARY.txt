================================================================================
MUJOCO DYNAMICS COMPUTATION - DETAILED ANALYSIS SUMMARY
================================================================================

ANALYSIS DATE: November 2, 2025
SOURCE FILES: 
  - /mujoco/src/engine/engine_core_smooth.c (2355 lines)
  - /mujoco/src/engine/engine_passive.c (1012 lines)
  - /mujoco/src/engine/engine_util_spatial.c (571 lines)
  - /mujoco/src/engine/engine_util_spatial.h (123 lines)

================================================================================
1. KEY FINDINGS
================================================================================

1.1 SPATIAL ALGEBRA FOUNDATION
   - MuJoCo uses 6D spatial vectors: [ω_x, ω_y, ω_z, v_x, v_y, v_z]
   - Angular component (rotation) FIRST, linear component (translation) SECOND
   - This differs from some screw theory implementations
   - Unified treatment of rotation and translation through spatial algebra

1.2 THREE CORE FUNCTIONS ANALYZED

   A. mj_comVel() - SPATIAL VELOCITY COMPUTATION
      Location: engine_core_smooth.c, lines 1932-1997
      Purpose: Compute spatial velocities and Coriolis terms
      Complexity: O(nv) - linear in number of DOFs
      
      Key operations:
      - Forward pass through kinematic tree
      - For each joint: compute cdof_dot = cvel × cdof (spatial cross-product)
      - Velocity propagation: cvel[i] = cvel[parent] + cdof * qvel
      - Different handling for FREE, BALL, HINGE/SLIDE joint types
      
      Critical detail: Uses parent velocity for cdof_dot (not updated velocity)
      Reason: Numerically more stable; cvel_old × cdof = same as cvel_new × cdof
              since cdof is velocity-independent

   B. mj_rne() - RECURSIVE NEWTON-EULER ALGORITHM
      Location: engine_core_smooth.c, lines 2068-2119
      Purpose: Compute joint torques/forces (inverse dynamics)
      Complexity: O(nv) - tree structure enables linear scaling
      
      Four phases:
      1. Forward pass: cacc[i] = cacc[parent] + cdof_dot * qvel + cdof * qacc
      2. Force computation: cfrc_body[i] = I[i] * cacc[i] + cvel[i] × (I[i] * cvel[i])
      3. Backward pass: Accumulate forces up the tree
      4. Projection: τ[j] = cdof[j]^T · cfrc_body[body[j]]
      
      Key insight: Centrifugal force computed as cvel × (I * cvel)
                   This term vanishes when flg_acc=0 (Coriolis only)

   C. mj_passive() - PASSIVE FORCES
      Location: engine_passive.c, lines 599-688
      Purpose: Compute springs, dampers, and other passive forces
      Complexity: O(njnt + ntendon)
      
      Components:
      - DOF damping: qfrc_damper[i] = -b[i] * qvel[i]
      - Joint springs: qfrc_spring[j] = -k[j] * (q[j] - q_rest[j])
      - Ball joint springs: Special handling via quaternion difference
      - Tendon springs: With length bounds (upper/lower limits)
      - Gravity compensation, fluid forces, contact forces

1.3 CRITICAL SPATIAL ALGEBRA OPERATIONS

   mju_crossMotion(res, vel, v):
   - Computes Lie bracket for motion vectors
   - Formula: res = [-ω × ω_v, -ω × v_v - ω_v × v_ω]
   - Used for: Computing velocity-dependent accelerations (Coriolis)
   
   mju_crossForce(res, vel, f):
   - Computes Lie bracket for force vectors  
   - Formula: res = [-ω × τ - v_f × f_f, -ω × f_f]
   - Used for: Computing centrifugal force
   
   mju_mulInertVec(res, inert, vec):
   - Multiplies 6x6 spatial inertia by 6D vector
   - Stored in compact 10-element form
   - Automatically handles rotation-translation coupling

1.4 NUMERICAL OPTIMIZATIONS

   - Quaternion normalization before spring torque computation
   - Stack allocation for temporary arrays (better cache, no fragmentation)
   - Parent velocity used for cdof_dot (numerically more stable)
   - Double-precision floating point (mjtNum = double)

================================================================================
2. EXACT LINE-BY-LINE ANALYSIS
================================================================================

2.1 mj_comVel() DETAILED BREAKDOWN
   
   Lines 1935-1936: Initialize world velocity to zero
   Lines 1939-1996: Main forward pass loop
   
   Line 1943-1945: Copy parent velocity
   Line 1947: Comment explains cdofdot = cvel × cdof relationship
   
   FREE joint (Lines 1955-1965):
   - Line 1957: cdofdot[0:18] = 0 (translational DOFs have no Coriolis)
   - Line 1960: mju_mulDofVec() adds translational velocity contribution
   - Line 1964: j += 3 to skip translational part
   - Line 1965: mjFALLTHROUGH to BALL case
   
   BALL joint (Lines 1967-1979):
   - Line 1970: mju_crossMotion() computes 3 Coriolis terms
   - Line 1974: mju_mulDofVec() adds rotational velocity
   - Line 1978: j += 2 (since loop will increment j further)
   
   HINGE/SLIDE (Lines 1981-1990):
   - Line 1985: Single mju_crossMotion() call
   - Line 1988: mju_mulDofVec() adds velocity contribution
   - Line 1982-1984: Important comment on numerical stability
   
   Lines 1993-1995: Store computed cvel and cdof_dot

2.2 mj_rne() DETAILED BREAKDOWN
   
   Lines 2069-2078: Initialization and allocation
   - Line 2072: Allocate local_cacc for spatial accelerations
   - Line 2073: Allocate local_cfrc_body for spatial forces
   - Line 2076-2078: Set gravity acceleration
   
   Forward pass (Lines 2082-2101):
   - Line 2084: Get body's first DOF address
   - Line 2087: Coriolis acceleration = cdof_dot * qvel
   - Line 2088: cacc = cacc_parent + Coriolis term
   - Line 2091-2093: Add inertial term (if flg_acc set)
   - Line 2097-2100: Compute spatial forces (inertial + centrifugal)
   
   Backward pass (Lines 2107-2111):
   - Accumulate forces from children to parent
   - Result: cfrc_body contains total force on body and descendants
   
   Projection (Lines 2114-2116):
   - Dot product of motion subspace with spatial force
   - Result: joint torque/force

2.3 Spring/Damper DETAILED BREAKDOWN

   DOF damping (Lines 116-123, engine_passive.c):
   - Line 120: qfrc_damper[i] = -damping * qvel[i]
   - Simple linear viscous model
   
   Joint springs (Lines 68-113):
   - Hinge/Slide (Lines 108-110):
     qfrc_spring = -k * (q - q_rest)
   - Ball joint (Lines 91-103):
     Uses mju_subQuat() to convert orientation difference to torque
   - FREE joint (Lines 80-89):
     Separate handling for translation and rotation

================================================================================
3. MATHEMATICAL FORMULAS IMPLEMENTED
================================================================================

3.1 SPATIAL VELOCITY PROPAGATION
    cvel[i] = cvel[parent[i]] + Σ_j (cdof[ij] * qvel[j])

3.2 CORIOLIS AND CENTRIFUGAL ACCELERATION
    cdof_dot[ij] = cvel[parent[i]] × cdof[ij]
    
    (Lie bracket computation - explains how motion subspace changes
     due to parent's rotational motion)

3.3 SPATIAL FORCE COMPUTATION
    cfrc_body[i] = I[i] * cacc[i] + cvel[i] × (I[i] * cvel[i])
    
    First term: Inertial force (proportional to acceleration)
    Second term: Centrifugal force (quadratic in velocity)

3.4 EQUATION OF MOTION (INVERSE DYNAMICS)
    τ = M(q) * qacc + C(q, qvel)
    
    where:
    τ = result from mj_rne() with flg_acc=1
    M(q) * qacc = contribution from accelerations
    C(q, qvel) = contribution from velocities (Coriolis/centrifugal)

================================================================================
4. KEY CODE SNIPPETS
================================================================================

4.1 SPATIAL CROSS-PRODUCT FOR MOTION (mju_crossMotion)
    Engine_util_spatial.c, lines 370-381
    
    Computes: res = vel × v where both are 6D spatial vectors
    Formula: res[0:3] = -ω × ω_v
             res[3:6] = -ω × v_v - ω_v × v_ω

4.2 SPATIAL CROSS-PRODUCT FOR FORCE (mju_crossForce)
    Engine_util_spatial.c, lines 385-396
    
    Computes: res = vel × f where vel and f are 6D
    Used for: Computing centrifugal force

4.3 SPATIAL INERTIA MULTIPLICATION (mju_mulInertVec)
    Engine_util_spatial.c, lines 434-441
    
    Multiplies 6x6 spatial inertia matrix (stored in 10 elements)
    by 6D vector, handling all 36 multiplications

4.4 MOTION SUBSPACE MULTIPLICATION (mju_mulDofVec)
    Engine_util_spatial.c, lines 461-469
    
    Computes: Σ(cdof[k] * vec[k]) for n DOFs
    Handles single DOF case separately for efficiency

4.5 DAMPING FORCE
    Engine_passive.c, lines 116-123
    
    qfrc_damper[i] = -dof_damping[i] * qvel[i]
    Linear viscous damping, applied independently per DOF

4.6 SPRING FORCE (HINGE)
    Engine_passive.c, lines 108-110
    
    qfrc_spring[dof_adr] = -stiffness * (qpos[pos_adr] - qpos_spring[pos_adr])
    Hooke's law applied in joint space

4.7 SPRING FORCE (BALL JOINT)
    Engine_passive.c, lines 92-103
    
    Uses mju_subQuat() to convert quaternion difference to angular velocity
    Then applies: qfrc_spring = -stiffness * angular_vel_diff
    Special handling avoids quaternion gimbal lock issues

================================================================================
5. DATA STRUCTURE REFERENCE
================================================================================

5.1 d->cvel[6*nbody]
    Spatial velocity of each body (in composite frame, at COM)
    Layout: [body_0, body_1, ..., body_nbody-1]
    Each entry: [ω_x, ω_y, ω_z, v_x, v_y, v_z]

5.2 d->cdof[6*nv]
    Motion subspace vectors (one per DOF)
    For hinge: [axis, axis × offset_from_com]
    For slide: [0, 0, 0, axis]
    For ball: 3 orthonormal rotational axes

5.3 d->cdof_dot[6*nv]
    Time derivative of motion subspace (Coriolis effect)
    Computed as: cvel × cdof for each DOF

5.4 d->cinert[10*nbody]
    Spatial inertia matrix (stored in compact form)
    Elements: [I_xx, I_yy, I_zz, I_xy, I_xz, I_yz, m*c_x, m*c_y, m*c_z, m]

5.5 d->cfrc_body[6*nbody]
    Spatial force acting on body (in composite frame)
    Layout: [torque_x, torque_y, torque_z, force_x, force_y, force_z]

================================================================================
6. PERFORMANCE ANALYSIS
================================================================================

6.1 TIME COMPLEXITY
    mj_comVel():     O(nv)
    mj_rne():        O(nv)
    mj_passive():    O(njnt + ntendon)
    
    Tree structure enables linear complexity (not quadratic)

6.2 MEMORY USAGE
    mj_rne() temporary allocation: O(nbody)
    Stack-allocated for automatic deallocation

6.3 NUMERICAL PRECISION
    Double precision (mjtNum = double)
    Quaternion normalization to prevent drift
    Careful ordering of operations for stability

================================================================================
7. CRITICAL INSIGHTS
================================================================================

7.1 WHY SPATIAL ALGEBRA?
    - Unified treatment of rotation and translation
    - Automatic handling of kinematic constraints
    - Numerically stable cross-product operations
    - Natural Jacobian representation

7.2 WHY COMPOSITE FRAMES?
    - Each body has 6 DOF (not 12)
    - Smaller matrices = faster computation
    - Natural place to apply inertia and constraints
    - Automatic COM-based representation

7.3 WHY MOTION SUBSPACE?
    - Encodes joint structure efficiently
    - Coriolis terms naturally via Lie bracket
    - Jacobian explicitly available
    - Works uniformly for all joint types

7.4 WHY TREE STRUCTURE?
    - Forward and backward passes are O(nbody)
    - No need to invert large matrices
    - Cache-efficient computation
    - Naturally handles branched structures

================================================================================
8. INTEGRATION WITH FORWARD DYNAMICS
================================================================================

Typical call sequence in mj_forward():

1. mj_kinematics()      - Compute body positions/orientations (xpos, xmat)
2. mj_comPos()          - Map inertias to COM frame, compute cdof
3. mj_comVel()          - Compute spatial velocities (cvel, cdof_dot)
4. mj_rne()             - Compute Coriolis forces (flg_acc=0)
5. mj_rnePostConstraint() - Complete acceleration computation
6. Integration step     - Update velocities and positions

Data flow:
   qpos, qvel -> mj_kinematics() -> xpos, xmat, xquat
              -> mj_comPos()     -> cinert, cdof
              -> mj_comVel()     -> cvel, cdof_dot
              -> mj_rne()        -> result (forces/torques)
              -> mj_passive()    -> qfrc_passive (damping, springs)
              -> Forward integration -> new qpos, qvel

================================================================================
9. VERIFICATION AND DEBUGGING
================================================================================

Key properties to verify:
- Energy conservation (with no damping)
- Force balance at equilibrium
- Coriolis term symmetry
- Damping force dissipation

Spatial vector format reminder:
  [0:3] = angular component (ω)
  [3:6] = linear component (v)

Print example:
  printf("cvel[%d] = [%.6f, %.6f, %.6f | %.6f, %.6f, %.6f]\n",
         i, d->cvel[6*i], d->cvel[6*i+1], d->cvel[6*i+2],
         d->cvel[6*i+3], d->cvel[6*i+4], d->cvel[6*i+5]);

================================================================================
10. COMMON IMPLEMENTATION MISTAKES
================================================================================

1. Mixing global and composite frames
2. Incorrect Coriolis formula (should use Lie bracket, not simple cross-product)
3. Quaternion gimbal lock in ball joint springs
4. Using updated velocity for cdof_dot (should use parent's velocity)
5. Forgetting to normalize quaternions
6. Incorrect spatial inertia layout
7. Wrong sign for gravity (should be negative)
8. Forgetting backward pass in RNE

================================================================================
END OF SUMMARY
================================================================================

Full detailed analysis available in: MUJOCO_DYNAMICS_DETAILED.md

Document generated: November 2, 2025
Analysis tool: Claude Code (Haiku 4.5)
Thoroughness level: VERY THOROUGH (complete code walkthrough with exact line numbers)
